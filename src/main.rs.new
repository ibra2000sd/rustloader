//! Rustloader - High-Performance Video Downloader
//! 
//! A cross-platform video downloader that combines yt-dlp extraction capabilities
//! with a fast Rust-based download engine and a simple, practical GUI.

use std::env;
use std::process::Command;
use std::path::PathBuf;
use anyhow::Result;
use clap::Parser;
use tracing::{info, error, warn};
use tracing_subscriber;

// Import all modules
mod app;
mod extractor;
mod downloader;
mod queue;
mod database;
mod gui;
mod utils;

/// Command-line arguments
#[derive(Parser)]
struct Args {
    /// Test download with provided URL
    #[arg(long)]
    test_download: Option<String>,
}

/// Main entry point
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Parse command-line arguments
    let args = Args::parse();

    // Initialize logging
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();

    info!("Starting Rustloader...");

    // Check for CLI test mode
    if args.test_download.is_some() {
        let url = args.test_download.unwrap();
        info!("CLI Test Mode: Downloading {}", url);
        return run_cli_test(&url);
    }

    // Check if yt-dlp is installed
    check_ytdlp_installed()?;

    // Initialize database
    initialize_database()?;

    // Run GUI application
    info!("Launching GUI...");
    gui::run().map_err(|e| {
        error!("GUI error: {}", e);
        Box::new(std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("GUI failed: {}", e)
        )) as Box<dyn std::error::Error>
    })?;

    Ok(())
}

/// Check if yt-dlp is installed and accessible
fn check_ytdlp_installed() -> Result<(), Box<dyn std::error::Error>> {
    info!("Checking for yt-dlp...");

    let output = Command::new("yt-dlp")
        .arg("--version")
        .output();

    match output {
        Ok(output) if output.status.success() => {
            let version = String::from_utf8_lossy(&output.stdout);
            info!("âœ“ yt-dlp found: version {}", version.trim());
            Ok(())
        }
        _ => {
            eprintln!("
âŒ ERROR: yt-dlp not found!");
            eprintln!("Rustloader requires yt-dlp to extract video information.");
            eprintln!("
Please install yt-dlp:");
            eprintln!("  â€¢ pip install yt-dlp");
            eprintln!("  â€¢ brew install yt-dlp (macOS)");
            eprintln!("  â€¢ Visit: https://github.com/yt-dlp/yt-dlp
");

            Err(Box::new(std::io::Error::new(
                std::io::ErrorKind::NotFound,
                "yt-dlp not found"
            )))
        }
    }
}

/// Initialize the SQLite database
fn initialize_database() -> Result<(), Box<dyn std::error::Error>> {
    info!("Initializing database...");

    // Create runtime for async database initialization
    let rt = tokio::runtime::Runtime::new()?;

    // Determine database path
    let db_path = dirs::data_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("rustloader")
        .join("rustloader.db");

    // Create directory if it doesn't exist
    if let Some(parent) = db_path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    // Initialize database
    let db_path_str = db_path.to_string_lossy();
    rt.block_on(async {
        database::initialize_database(&db_path_str).await
    })?;

    info!("âœ“ Database initialized");
    Ok(())
}

/// Run CLI test mode for downloading a single video
fn run_cli_test(url: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("
ðŸ§ª Rustloader CLI Test Mode");
    println!("============================
");
    println!("Testing download: {}
", url);

    // Create runtime for async operations
    let rt = tokio::runtime::Runtime::new()?;

    rt.block_on(async {
        // Initialize extractor
        println!("Initializing extractor...");
        let extractor = extractor::VideoExtractor::new()?;

        // Extract video info
        println!("Extracting video information...");
        let video_info = extractor.extract_info(url).await
            .map_err(|e| format!("Extraction failed: {}", e))?;

        println!("âœ“ Title: {}", video_info.title);
        if let Some(size) = video_info.filesize {
            println!("âœ“ Size: {:.2} MB", size as f64 / 1_024_000.0);
        }
        if let Some(duration) = video_info.duration {
            println!("âœ“ Duration: {}s", duration);
        }
        println!();

        // Get best format
        let format = video_info.formats
            .iter()
            .max_by_key(|f| f.filesize.unwrap_or(0))
            .ok_or("No formats available")?;

        println!("Selected format: {} ({})", format.ext, 
            format.resolution.as_deref().unwrap_or("unknown"));
        println!();

        // Initialize download engine
        println!("Starting download...");
        let config = downloader::DownloadConfig {
            segments: 16,
            retry_attempts: 3,
            enable_resume: true,
            ..Default::default()
        };

        let engine = downloader::DownloadEngine::new(config);

        // Create output path
        let output_dir = env::current_dir()?;
        let filename = sanitize_filename(&video_info.title);
        let output_path = output_dir.join(format!("{}.{}", filename, format.ext));

        println!("Output: {}", output_path.display());
        println!();

        // Create progress channel
        let (tx, mut rx) = tokio::sync::mpsc::channel(100);

        // Spawn download task
        let download_handle = tokio::spawn({
            let engine = engine.clone();
            let url = format.url.clone();
            let output = output_path.clone();
            async move {
                engine.download(&url, &output, tx).await
            }
        });

        // Monitor progress
        let mut last_progress = 0.0;
        while let Some(progress) = rx.recv().await {
            let percent = (progress.downloaded_bytes as f64 / progress.total_bytes as f64) * 100.0;

            if percent - last_progress >= 5.0 || percent >= 99.0 {
                println!(
                    "Progress: {:.1}% - {:.2} MB/s",
                    percent,
                    progress.speed / 1_024_000.0
                );
                last_progress = percent;
            }
        }

        // Wait for download to complete
        download_handle.await
            .map_err(|e| format!("Download task failed: {}", e))?
            .map_err(|e| format!("Download failed: {}", e))?;

        println!("
âœ“ Download complete!");
        println!("âœ“ File saved to: {}", output_path.display());
        println!("
âœ… Test passed successfully!
");

        Ok::<(), Box<dyn std::error::Error>>(())
    })
}

/// Sanitize filename for filesystem
fn sanitize_filename(filename: &str) -> String {
    filename
        .chars()
        .map(|c| match c {
            '/' | '\' | ':' | '*' | '?' | '"' | '<' | '>' | '|' => '_',
            _ => c,
        })
        .take(200)  // Limit filename length
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sanitize_filename() {
        assert_eq!(
            sanitize_filename("Video: Test/File?.mp4"),
            "Video_ Test_File_.mp4"
        );
    }

    #[test]
    fn test_ytdlp_check() {
        // This test will fail if yt-dlp is not installed
        // which is expected behavior
        let result = check_ytdlp_installed();
        println!("yt-dlp check result: {:?}", result);
    }
}
